<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Budget App with Google Sheets Backend</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 2em; background: #f9f9f9; }
    h1 { color: #2d3e50; }
    table { border-collapse: collapse; width: 100%; margin-bottom: 2em; }
    th, td { border: 1px solid #ddd; padding: 8px; }
    th { background: #e3e3e3; }
    tr:nth-child(even) { background: #f4f4f4; }
    #addForm, #calculatorSection { margin-bottom: 2em; background: #fff; padding: 1em; border: 1px solid #ddd; }
    #addForm input, #addForm select { margin: 0 4px 8px 0; }
    button { padding: 8px 16px; }
    .success { color: green; }
    .error { color: red; }
    .calculator-modal {
      position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(0,0,0,0.5); display: none; align-items: center; justify-content: center;
    }
    .calculator-content {
      background: #fff; padding: 2em; border-radius: 10px; max-width: 600px; width: 90%; box-shadow: 0 4px 16px rgba(0,0,0,0.3);
    }
    .close-modal { float: right; cursor: pointer; color: #888; font-size: 22px; }
  </style>
</head>
<body>
  <h1>Budget App</h1>
  <div id="status"></div>
  <form id="addForm">
    <strong>Add Row:</strong><br>
    Section: <select name="Section">
      <option>Income</option>
      <option>Housing</option>
      <option>Insurance</option>
      <option>Food</option>
      <option>Transportation</option>
      <option>Lifestyle</option>
      <option>Debt</option>
      <option>Savings</option>
    </select>
    Name: <input name="Name" required>
    Original Balance: <input name="Original Balance" type="number" step="0.01">
    Remaining Balance: <input name="Remaining Balance" type="number" step="0.01">
    Interest Rate: <input name="Interest Rate" type="number" step="0.01">
    Planned Amount: <input name="Planned Amount" type="number" step="0.01">
    Received Amount: <input name="Received Amount" type="number" step="0.01">
    Monthly Payment: <input name="Monthly Payment" type="number" step="0.01">
    Paid So Far: <input name="Paid So Far" type="number" step="0.01">
    Due Date: <input name="Due Date" type="text">
    Select: <select name="Select"><option value="FALSE">No</option><option value="TRUE">Yes</option></select>
    <button type="submit">Add</button>
  </form>
  <div id="calculatorSection">
    <strong>Debt Payoff Calculators:</strong><br>
    Additional Monthly Payment: <input id="extraPaymentInput" type="number" value="0" step="0.01">
    <button onclick="showCalculator('snowball')">Snowball Payoff</button>
    <button onclick="showCalculator('avalanche')">Avalanche Payoff</button>
  </div>
  <table id="budgetTable"></table>

  <!-- Calculator Modal -->
  <div id="calculatorModal" class="calculator-modal">
    <div class="calculator-content">
      <span class="close-modal" onclick="closeCalculatorModal()">&times;</span>
      <h2 id="calculatorTitle"></h2>
      <div id="calculatorResults"></div>
    </div>
  </div>
  <script>
    const SHEETS_URL = "https://script.google.com/macros/s/AKfycbzBK-wqMAyrJOM1SfLemwNoQ-1GiZ_ClFNghfkt_jOOoIqFfpD6NCvQqDlSom9BpMfL/exec";
    const statusDiv = document.getElementById('status');
    const table = document.getElementById('budgetTable');
    const addForm = document.getElementById('addForm');
    const calculatorModal = document.getElementById('calculatorModal');
    const calculatorTitle = document.getElementById('calculatorTitle');
    const calculatorResults = document.getElementById('calculatorResults');
    const extraPaymentInput = document.getElementById('extraPaymentInput');
    let sheetData = [];
    let headers = [];
    
    // Fetch and render data from Google Sheets
    function fetchSheetData() {
      statusDiv.textContent = 'Loading data...';
      fetch(SHEETS_URL)
        .then(resp => resp.json())
        .then(data => {
          sheetData = data;
          headers = data[0];
          renderTable(data);
        })
        .catch(e => {
          statusDiv.textContent = 'Error loading data!';
          statusDiv.className = 'error';
        });
    }

    // Render table from sheet data
    function renderTable(data) {
      if (!data || !data.length) {
        table.innerHTML = '<tr><td>No data available.</td></tr>';
        statusDiv.textContent = '';
        return;
      }
      let html = '<tr>' + data[0].map(h => `<th>${h}</th>`).join('') + '<th>Delete</th></tr>';
      for (let i = 1; i < data.length; i++) {
        html += '<tr>';
        for (let j = 0; j < data[i].length; j++) {
          // Make cells editable except for Section
          if (j === 0) {
            html += `<td>${data[i][j]}</td>`;
          } else {
            html += `<td contenteditable="true" data-row="${i}" data-col="${j}">${data[i][j]}</td>`;
          }
        }
        html += `<td><button onclick="deleteRow(${i})">Delete</button></td></tr>`;
      }
      table.innerHTML = html;
      statusDiv.textContent = '';
      // Add event listeners for inline editing
      Array.from(table.querySelectorAll('td[contenteditable="true"]')).forEach(cell => {
        cell.addEventListener('blur', function() {
          let row = parseInt(cell.getAttribute('data-row'));
          let col = parseInt(cell.getAttribute('data-col'));
          let newValue = cell.textContent;
          updateCell(row, col, newValue);
        });
      });
    }

    // Add a new row
    addForm.addEventListener('submit', function(e) {
      e.preventDefault();
      const formData = new FormData(addForm);
      const row = [
        formData.get('Section') || '',
        formData.get('Name') || '',
        formData.get('Original Balance') || '',
        formData.get('Remaining Balance') || '',
        formData.get('Interest Rate') || '',
        formData.get('Planned Amount') || '',
        formData.get('Received Amount') || '',
        formData.get('Monthly Payment') || '',
        formData.get('Paid So Far') || '',
        formData.get('Due Date') || '',
        formData.get('Select') || ''
      ];
      statusDiv.textContent = 'Adding row...';
      fetch(SHEETS_URL, {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({row})
      })
      .then(resp => resp.json())
      .then(result => {
        if (result.result === "success") {
          statusDiv.textContent = 'Row added!';
          statusDiv.className = 'success';
          fetchSheetData();
          addForm.reset();
        } else {
          statusDiv.textContent = 'Error adding row!';
          statusDiv.className = 'error';
        }
      })
      .catch(e => {
        statusDiv.textContent = 'Error adding row!';
        statusDiv.className = 'error';
      });
    });

    // Delete a row
    function deleteRow(rowIndex) {
      if (!confirm('Delete this row?')) return;
      statusDiv.textContent = 'Deleting row...';
      fetch(SHEETS_URL, {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({delete: rowIndex})
      })
      .then(resp => resp.json())
      .then(result => {
        if (result.result === "success") {
          statusDiv.textContent = 'Row deleted!';
          statusDiv.className = 'success';
          fetchSheetData();
        } else {
          statusDiv.textContent = 'Error deleting row!';
          statusDiv.className = 'error';
        }
      })
      .catch(e => {
        statusDiv.textContent = 'Error deleting row!';
        statusDiv.className = 'error';
      });
    }
    window.deleteRow = deleteRow;

    // Update a cell
    function updateCell(rowIndex, colIndex, newValue) {
      statusDiv.textContent = 'Updating cell...';
      fetch(SHEETS_URL, {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({update: { row: rowIndex, col: colIndex, value: newValue }})
      })
      .then(resp => resp.json())
      .then(result => {
        if (result.result === "success") {
          statusDiv.textContent = 'Cell updated!';
          statusDiv.className = 'success';
          fetchSheetData();
        } else {
          statusDiv.textContent = 'Error updating cell!';
          statusDiv.className = 'error';
        }
      })
      .catch(e => {
        statusDiv.textContent = 'Error updating cell!';
        statusDiv.className = 'error';
      });
    }

    // Debt payoff calculators
    function showCalculator(type) {
      // Gather debts from table
      let debts = [];
      for (let i = 1; i < sheetData.length; i++) {
        if (sheetData[i][0] === "Debt") {
          debts.push({
            name: sheetData[i][1],
            balance: parseFloat(sheetData[i][3]) || 0,
            rate: parseFloat(sheetData[i][4]) || 0,
            payment: parseFloat(sheetData[i][7]) || 0,
          });
        }
      }
      let extra = parseFloat(extraPaymentInput.value) || 0;
      let result;
      if (type === 'snowball') {
        result = calculateSnowball(debts, extra);
        calculatorTitle.textContent = "Snowball Payoff Results";
      } else {
        result = calculateAvalanche(debts, extra);
        calculatorTitle.textContent = "Avalanche Payoff Results";
      }
      calculatorResults.innerHTML = result;
      calculatorModal.style.display = 'flex';
    }

    function closeCalculatorModal() {
      calculatorModal.style.display = 'none';
    }
    window.closeCalculatorModal = closeCalculatorModal;

    // Snowball: smallest balance first
    function calculateSnowball(debts, extra) {
      debts = debts.slice().sort((a,b) => a.balance - b.balance);
      return calculateDebtPayoff(debts, extra, "Snowball");
    }
    // Avalanche: highest rate first
    function calculateAvalanche(debts, extra) {
      debts = debts.slice().sort((a,b) => b.rate - a.rate);
      return calculateDebtPayoff(debts, extra, "Avalanche");
    }
    // Debt payoff logic
    function calculateDebtPayoff(debts, extra, method) {
      let months = 0, schedule = [];
      let totalPaid = 0;
      let debtsCopy = debts.map(d => ({...d}));
      let done = false;
      let start = new Date();
      while (!done && months < 600) { // Prevent infinite loop
        months++;
        let paymentPool = extra;
        for (let i = 0; i < debtsCopy.length; i++) {
          let d = debtsCopy[i];
          if (d.balance <= 0) continue;
          let interest = d.balance * (d.rate/100/12);
          let payAmt = Math.min(d.payment + paymentPool, d.balance + interest);
          d.balance += interest;
          d.balance -= payAmt;
          totalPaid += payAmt;
          paymentPool = Math.max(0, paymentPool - (payAmt - d.payment));
          if (d.balance < 0.01) d.balance = 0;
          // If paid off, roll payment into next
          if (d.balance === 0 && paymentPool > 0 && i < debtsCopy.length-1) {
            debtsCopy[i+1].payment += d.payment;
          }
        }
        done = debtsCopy.every(d => d.balance <= 0);
        let payoffState = debtsCopy.map(d => `${d.name}: $${d.balance.toFixed(2)}`).join(' | ');
        schedule.push(`Month ${months}: ${payoffState}`);
      }
      let payoffDate = new Date(start.setMonth(start.getMonth() + months));
      let html = `<b>Full payoff in ${months} months (${payoffDate.toLocaleDateString()})</b><br>`;
      html += `<b>Total Paid:</b> $${totalPaid.toFixed(2)}<br>`;
      html += `<details><summary>Monthly Schedule (click to expand)</summary>${schedule.map(s => `<div>${s}</div>`).join('')}</details>`;
      return html;
    }

    // Initial table load
    fetchSheetData();
  </script>
</body>
</html>
